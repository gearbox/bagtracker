name: $COMPOSE_PROJECT_NAME
services:
  app-backend:
    environment:
      - UVICORN_WORKERS=${UVICORN_WORKERS:-4}
      - COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME}
      - BACKEND_HOST=${BACKEND_HOST}
      - BACKEND_PORT=${BACKEND_PORT}
      - BIND_HOST_PORT=${BIND_HOST_PORT}
      - BIND_HOST=${BIND_HOST}
      - APP_NAME=${APP_NAME}
      - TOKEN_HEADER_NAME=${TOKEN_HEADER_NAME}
      - TOKEN=${TOKEN}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    env_file:
      - path: .env
        required: false
    build:
      context: .
      dockerfile: ./docker/app/Dockerfile
    container_name: app-backend
    hostname: app-backend
    networks:
      - app-network
    ports:
      - "$BIND_HOST:$BIND_HOST_PORT:$BACKEND_PORT"
    volumes:
      - ./backend:/code
      - ./var/log/backend:/code/log
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: [ "CMD-SHELL", "/bin/bash -c 'exec 3<>/dev/tcp/$BACKEND_HOST/$BACKEND_PORT;echo -e \"GET /healthcheck HTTP/1.1\r\nhost: http://$BACKEND_HOST\r\nConnection: close\r\n\r\n\" >&3;grep \"HTTP/1.1 200 OK\" <&3'" ]
      interval: 30s
      timeout: 5s
      retries: 5
    # Option 1: Using Python directly (Production)
    # entrypoint: [
    #   "/bin/bash", "-c", 
    #   "alembic upgrade head && python -c 'from backend.asgi import run_production; run_production()'"
    # ]
    # Option 2: Using Python directly (DEVELOPMENT)
    entrypoint: [
      "/bin/bash", "-c", 
      "alembic upgrade head && python -c 'from backend.asgi import run_uvicorn; run_uvicorn()'"
    ]
    # Option 3: Using command line with config
    # entrypoint: [
    #   "/bin/bash", "-c", 
    #   "alembic upgrade head && uvicorn backend.asgi:app --host $BACKEND_HOST --port $BACKEND_PORT --workers $UVICORN_WORKERS --timeout-keep-alive 180 --log-level info"
    # ]
    restart: always

  db:
    environment:
      - BIND_HOST=${BIND_HOST}
      - POSTGRES_HOST=${POSTGRES_HOST}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    env_file:
      - path: .env
        required: false
    build:
      context: .
      dockerfile: ./docker/db/Dockerfile
    container_name: portfolio-db
    hostname: portfolio-db
    networks:
      - app-network
    ports:
      - "$BIND_HOST:$POSTGRES_PORT:$POSTGRES_PORT"
    volumes:
      - ./var/db/postgresql/app:/var/lib/postgresql/data
    # please uncomment next line to enable full PostgreSQL logging
    # it might be very useful for debugging purposes
    # command: ["postgres", "-c", "log_statement=all", "-c", "log_destination=stderr"]
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "postgres", "-d", "postgres" ]
      interval: 15s
      retries: 5
    restart: always

  redis:
    image: redis:latest
    environment:
      - REDIS_HOST=${REDIS_HOST}
      - REDIS_PORT=${REDIS_PORT}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    env_file:
      - path: .env
        required: false
    container_name: redis
    hostname: redis
    networks:
      - app-network
    volumes:
      - ./var/db/redis:/data
    command: ["redis-server", "--requirepass", $REDIS_PASSWORD]
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      interval: 15s
      timeout: 30s
      retries: 5
    restart: always

  taskiq-worker:
    environment:
      - COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - REDIS_HOST=${REDIS_HOST}
      - REDIS_PORT=${REDIS_PORT}
    env_file:
      - path: .env
        required: false
    build:
      context: .
      dockerfile: ./docker/app/Dockerfile
    container_name: taskiq-worker
    hostname: taskiq-worker
    networks:
      - app-network
    volumes:
      - ./backend:/code
      - ./var/log/taskiq:/code/log
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: ["taskiq", "worker", "backend.taskiq_broker:broker", "--fs-discover"]
    restart: always

  taskiq-scheduler:
    environment:
      - COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - REDIS_HOST=${REDIS_HOST}
      - REDIS_PORT=${REDIS_PORT}
    env_file:
      - path: .env
        required: false
    build:
      context: .
      dockerfile: ./docker/app/Dockerfile
    container_name: taskiq-scheduler
    hostname: taskiq-scheduler
    networks:
      - app-network
    volumes:
      - ./backend:/code
      - ./var/log/taskiq:/code/log
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: ["taskiq", "scheduler", "backend.scheduler:scheduler"]
    restart: always

networks:
  app-network:
    driver: bridge

volumes:
  db_data: